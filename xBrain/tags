!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACE	Cpp/cfg_reader.cpp	/^namespace ACE {$/;"	n	file:
ACE	Cpp/cfg_reader.h	/^namespace ACE$/;"	n
AdjustLen	Cpp/DataNode.cpp	/^	int DataNode::AdjustLen(int diff)$/;"	f	class:DS::DataNode
CC	build/Makefile	/^CC = gcc$/;"	m
CCfgReader	Cpp/cfg_reader.cpp	/^CCfgReader::CCfgReader(const string &strfile):_strfile(strfile), _bscan(false) {$/;"	f	class:ACE::CCfgReader
CCfgReader	Cpp/cfg_reader.h	/^class CCfgReader$/;"	c	namespace:ACE
CFLAGS	build/Makefile	/^CFLAGS = -Wall -std=gnu99 $/;"	m
CPP	build/Makefile	/^CPP = g++$/;"	m
CPPFLAGS	build/Makefile	/^CPPFLAGS = -Wall  $/;"	m
C_OBJS_NO_DIR	build/Makefile	/^C_OBJS_NO_DIR = $(notdir $(OBJS))$/;"	m
DATA_GET_TYPE_DEFAULT	Cpp/DataNode.h	15;"	d
DATA_GET_TYPE_PEEK	Cpp/DataNode.h	16;"	d
DEFAULT_BUFF_LEN	Cpp/DataNode.h	17;"	d
DEFAULT_THREAD_NUM	Cpp/threadpool.c	12;"	d	file:
DEFAULT_TIME	Cpp/threadpool.c	10;"	d	file:
DIRS	build/Makefile	/^DIRS := $(DIR_OBJS) $(DIR_EXEC) $(DIR_OBJS_CPP)$/;"	m
DIR_EXEC	build/Makefile	/^DIR_EXEC = ..\/exec$/;"	m
DIR_OBJS	build/Makefile	/^DIR_OBJS = ..\/objs_c$/;"	m
DIR_OBJS_CPP	build/Makefile	/^DIR_OBJS_CPP = ..\/objs_cpp$/;"	m
DS	Cpp/DataNode.cpp	/^namespace DS$/;"	n	file:
DS	Cpp/DataNode.h	/^namespace DS$/;"	n
DataNode	Cpp/DataNode.cpp	/^	DataNode::DataNode()$/;"	f	class:DS::DataNode
DataNode	Cpp/DataNode.cpp	/^	DataNode::DataNode(int len)$/;"	f	class:DS::DataNode
DataNode	Cpp/DataNode.h	/^class DataNode$/;"	c	namespace:DS
DoTest	Cpp/CJSONTest.cpp	/^void DoTest()$/;"	f
EXEC	build/Makefile	/^EXEC := $(addprefix $(DIR_EXEC)\/,$(EXEC))$/;"	m
EXEC	build/Makefile	/^EXEC = xBrain $/;"	m
GenSession	Cpp/HttpResponseParse-main.cpp	/^int GenSession(char *dst, int dstlen)$/;"	f
GetBodys	Cpp/HttpResponseParse.h	/^	std::map<int, DS::DataNode *> & GetBodys()$/;"	f	class:HttpResponseParse
GetBuff	Cpp/DataNode.cpp	/^	char* DataNode::GetBuff()$/;"	f	class:DS::DataNode
GetCapacity	Cpp/DataNode.cpp	/^	int DataNode::GetCapacity()$/;"	f	class:DS::DataNode
GetDataLen	Cpp/DataNode.cpp	/^	int DataNode::GetDataLen() const$/;"	f	class:DS::DataNode
GetDataNode	Cpp/HttpResponseParse.h	/^	DS::DataNode *GetDataNode()$/;"	f	class:HttpResponseParse
GetHeaders	Cpp/HttpResponseParse.h	/^	std::map<string, string> & GetHeaders()$/;"	f	class:HttpResponseParse
GetHttpCode	Cpp/HttpResponseParse.h	/^	int GetHttpCode()$/;"	f	class:HttpResponseParse
GetOptValue	Cpp/cfg_reader.cpp	/^string CCfgReader::GetOptValue(const char *section, const char *szname, const string &strdefault) {$/;"	f	class:ACE::CCfgReader
GetPhase	Cpp/HttpResponseParse.cpp	/^HttpParsePhase HttpResponseParse::GetPhase()$/;"	f	class:HttpResponseParse
GetResponseLine	Cpp/HttpResponseParse.cpp	/^const string& HttpResponseParse::GetResponseLine()$/;"	f	class:HttpResponseParse
GetSpaceLen	Cpp/DataNode.cpp	/^	int DataNode::GetSpaceLen()$/;"	f	class:DS::DataNode
GetValue	Cpp/cfg_reader.cpp	/^string CCfgReader::GetValue(const char * section, const char *szname) {$/;"	f	class:ACE::CCfgReader
HEAD_LINE_END	Cpp/HttpPacker.h	17;"	d
HttpPacker	Cpp/HttpPacker.cpp	/^HttpPacker::HttpPacker()$/;"	f	class:HttpPacker
HttpPacker	Cpp/HttpPacker.h	/^class HttpPacker$/;"	c
HttpPackerTest	Cpp/HttpResponseParse-main.cpp	/^int HttpPackerTest(int argc, char** argv) $/;"	f
HttpParsePhase	Cpp/HttpResponseParse.h	/^enum  HttpParsePhase$/;"	g
HttpParse_Body	Cpp/HttpResponseParse.h	/^	HttpParse_Body,		\/\/ 获取到了 body $/;"	e	enum:HttpParsePhase
HttpParse_End	Cpp/HttpResponseParse.h	/^	HttpParse_End,     	\/\/ 获取到了所有数据 $/;"	e	enum:HttpParsePhase
HttpParse_Headers	Cpp/HttpResponseParse.h	/^	HttpParse_Headers, 	\/\/ 获取到了所有 headers $/;"	e	enum:HttpParsePhase
HttpParse_Response	Cpp/HttpResponseParse.h	/^	HttpParse_Response, \/\/ 获取到了 HTTP\/1.1 200 OK$/;"	e	enum:HttpParsePhase
HttpParse_Start	Cpp/HttpResponseParse.h	/^	HttpParse_Start = 0, 	\/\/ 还未获取到回应行 $/;"	e	enum:HttpParsePhase
HttpRequest	Cpp/HttpRequest.cpp	/^HttpRequest::HttpRequest()$/;"	f	class:HttpRequest
HttpRequest	Cpp/HttpRequest.h	/^class HttpRequest$/;"	c
HttpResponseParse	Cpp/HttpResponseParse.cpp	/^HttpResponseParse::HttpResponseParse()$/;"	f	class:HttpResponseParse
HttpResponseParse	Cpp/HttpResponseParse.cpp	/^HttpResponseParse::HttpResponseParse(int dn_len)$/;"	f	class:HttpResponseParse
HttpResponseParse	Cpp/HttpResponseParse.h	/^class HttpResponseParse$/;"	c
INI_FILE_PATH	Cpp/EmmManager-Test.cpp	4;"	d	file:
LDFLAGS	build/Makefile	/^LDFLAGS = -lpthread$/;"	m
LOG	C/rm_dir.c	20;"	d	file:
LOG	C/rm_dir.c	22;"	d	file:
LOG	Cpp/HttpPacker.h	7;"	d
LOG	Cpp/HttpPacker.h	9;"	d
MIN_WAIT_TASK_NUM	Cpp/threadpool.c	11;"	d	file:
MKDIR	build/Makefile	/^MKDIR = mkdir$/;"	m
NODIR_SRCS_C	build/Makefile	/^NODIR_SRCS_C = $(notdir $(SRCS))$/;"	m
NODIR_SRCS_CPP	build/Makefile	/^NODIR_SRCS_CPP = $(notdir $(SRCS_CPP))$/;"	m
OBJS	build/Makefile	/^OBJS := $(addprefix $(DIR_OBJS)\/,$(tmp))$/;"	m
OBJS	build/Makefile	/^OBJS = $(patsubst %.c,%.o, $(SRCS))$/;"	m
OBJS_CPP	build/Makefile	/^OBJS_CPP := $(addprefix $(DIR_OBJS_CPP)\/,$(tmp_cpp))$/;"	m
OBJS_CPP	build/Makefile	/^OBJS_CPP = $(patsubst %.cpp,%.o, $(SRCS_CPP))$/;"	m
Pack	Cpp/HttpPacker.cpp	/^emmstr* HttpPacker::Pack()$/;"	f	class:HttpPacker
Parse	Cpp/HttpResponseParse.cpp	/^int HttpResponseParse::Parse()$/;"	f	class:HttpResponseParse
PushData	Cpp/DataNode.cpp	/^	int DataNode::PushData(const char* src, int len)$/;"	f	class:DS::DataNode
PushData	Cpp/HttpResponseParse.cpp	/^int HttpResponseParse::PushData(const char *src, int len)$/;"	f	class:HttpResponseParse
RM	build/Makefile	/^RM = rm$/;"	m
ReadData	Cpp/DataNode.cpp	/^	int DataNode::ReadData(char* dst, int len, int type)$/;"	f	class:DS::DataNode
ReadIniFile	Cpp/EmmManager-Test.cpp	/^void ReadIniFile(const char *ini_file_path)$/;"	f
Request	Cpp/HttpRequest.cpp	/^void HttpRequest::Request(const HttpPacker &p)$/;"	f	class:HttpRequest
SPACE_LEN	Cpp/HttpPacker.h	16;"	d
SRCS	build/Makefile	/^SRCS = $(wildcard ..\/Cpp\/*.c)$/;"	m
SRCS_CPP	build/Makefile	/^SRCS_CPP = $(wildcard ..\/Cpp\/*.cpp)$/;"	m
ScanCfgFile	Cpp/cfg_reader.cpp	/^int CCfgReader::ScanCfgFile() {$/;"	f	class:ACE::CCfgReader
SetBody	Cpp/HttpPacker.cpp	/^void HttpPacker::SetBody(const char *body, int len)$/;"	f	class:HttpPacker
SetBody	Cpp/HttpPacker.cpp	/^void HttpPacker::SetBody(const char *pszbody)$/;"	f	class:HttpPacker
SetCallBack	Cpp/HttpRequest.cpp	/^void HttpRequest::SetCallBack(void (*done_callback)(int sockfd), int msgid)$/;"	f	class:HttpRequest
SetMethod	Cpp/HttpPacker.cpp	/^void HttpPacker::SetMethod(const char *method)\/\/ GET POST CONNECT etc. $/;"	f	class:HttpPacker
SetUrl	Cpp/HttpPacker.cpp	/^void HttpPacker::SetUrl(const char *url)$/;"	f	class:HttpPacker
SetVersion	Cpp/HttpPacker.cpp	/^void HttpPacker::SetVersion(const char *version)$/;"	f	class:HttpPacker
__BUFFER_NODE_H__	Cpp/DataNode.h	3;"	d
__CJSONTEST_H__	Cpp/CJSONTest.h	2;"	d
__COMMON_CFG_READER__	Cpp/cfg_reader.h	2;"	d
__EMM_MANAGER_TEST_	Cpp/BrainTest.cpp	9;"	d	file:
__EMM_MANAGER_TEST_H__	Cpp/EmmManager-Test.h	2;"	d
__HTTP_PACKER_H__	Cpp/HttpPacker.h	2;"	d
__HTTP_REQUEST_H__	Cpp/HttpRequest.h	2;"	d
__HTTP_RESPONSE_PARSE_H__	Cpp/HttpResponseParse-main.h	2;"	d
__HTTP_RESPONSE_PARSE_H__	Cpp/HttpResponseParse.h	2;"	d
__THREADPOOL_H_	Cpp/threadpool.h	2;"	d
__THREAD_POOL_H__	xBrainTest-Dev-C++/threadpool-test.h	2;"	d
_bscan	Cpp/cfg_reader.h	/^	bool _bscan;$/;"	m	class:ACE::CCfgReader
_buff	Cpp/DataNode.h	/^	char* _buff;$/;"	m	class:DS::DataNode
_capacity	Cpp/DataNode.h	/^	int _capacity;$/;"	m	class:DS::DataNode
_cfgdict	Cpp/cfg_reader.h	/^	map<string, map<string, string>*> _cfgdict;$/;"	m	class:ACE::CCfgReader
_from	Cpp/DataNode.h	/^	int	_from;$/;"	m	class:DS::DataNode
_strfile	Cpp/cfg_reader.h	/^	string _strfile;$/;"	m	class:ACE::CCfgReader
_to	Cpp/DataNode.h	/^	int _to;$/;"	m	class:DS::DataNode
admin_thread	Cpp/threadpool.c	/^admin_thread(void *threadpool)$/;"	f
admin_tid	Cpp/threadpool.c	/^   pthread_t admin_tid;                  \/* 管理者线程tid *\/$/;"	m	struct:threadpool_t	file:
arg	Cpp/threadpool.c	/^   void *arg;$/;"	m	struct:__anon1	file:
buf	Cpp/HttpPacker.h	/^	char *buf;$/;"	m	struct:emmstr
buffer	Cpp/CJson.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon2	file:
busy_thr_num	Cpp/threadpool.c	/^   int busy_thr_num;                     \/* 忙线程，正在工作的线程 *\/$/;"	m	struct:threadpool_t	file:
cJSON	Cpp/CJson.h	/^typedef struct cJSON {$/;"	s
cJSON	Cpp/CJson.h	/^} cJSON;$/;"	t	typeref:struct:cJSON
cJSON_AddBoolToObject	Cpp/CJson.h	137;"	d
cJSON_AddFalseToObject	Cpp/CJson.h	136;"	d
cJSON_AddItemReferenceToArray	Cpp/CJson.c	/^void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}$/;"	f
cJSON_AddItemReferenceToObject	Cpp/CJson.c	/^void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}$/;"	f
cJSON_AddItemToArray	Cpp/CJson.c	/^void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}$/;"	f
cJSON_AddItemToObject	Cpp/CJson.c	/^void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}$/;"	f
cJSON_AddItemToObjectCS	Cpp/CJson.c	/^void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}$/;"	f
cJSON_AddNullToObject	Cpp/CJson.h	134;"	d
cJSON_AddNumberToObject	Cpp/CJson.h	138;"	d
cJSON_AddStringToObject	Cpp/CJson.h	139;"	d
cJSON_AddTrueToObject	Cpp/CJson.h	135;"	d
cJSON_Array	Cpp/CJson.h	37;"	d
cJSON_CreateArray	Cpp/CJson.c	/^cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}$/;"	f
cJSON_CreateBool	Cpp/CJson.c	/^cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}$/;"	f
cJSON_CreateDoubleArray	Cpp/CJson.c	/^cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateFalse	Cpp/CJson.c	/^cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}$/;"	f
cJSON_CreateFloatArray	Cpp/CJson.c	/^cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateIntArray	Cpp/CJson.c	/^cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateNull	Cpp/CJson.c	/^cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}$/;"	f
cJSON_CreateNumber	Cpp/CJson.c	/^cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}$/;"	f
cJSON_CreateObject	Cpp/CJson.c	/^cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}$/;"	f
cJSON_CreateString	Cpp/CJson.c	/^cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}$/;"	f
cJSON_CreateStringArray	Cpp/CJson.c	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateTrue	Cpp/CJson.c	/^cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}$/;"	f
cJSON_Delete	Cpp/CJson.c	/^void cJSON_Delete(cJSON *c)$/;"	f
cJSON_DeleteItemFromArray	Cpp/CJson.c	/^void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}$/;"	f
cJSON_DeleteItemFromObject	Cpp/CJson.c	/^void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}$/;"	f
cJSON_DetachItemFromArray	Cpp/CJson.c	/^cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;$/;"	f
cJSON_DetachItemFromObject	Cpp/CJson.c	/^cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}$/;"	f
cJSON_Duplicate	Cpp/CJson.c	/^cJSON *cJSON_Duplicate(cJSON *item,int recurse)$/;"	f
cJSON_False	Cpp/CJson.h	32;"	d
cJSON_GetArrayItem	Cpp/CJson.c	/^cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}$/;"	f
cJSON_GetArraySize	Cpp/CJson.c	/^int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}$/;"	f
cJSON_GetErrorPtr	Cpp/CJson.c	/^const char *cJSON_GetErrorPtr(void) {return ep;}$/;"	f
cJSON_GetObjectItem	Cpp/CJson.c	/^cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}$/;"	f
cJSON_Hooks	Cpp/CJson.h	/^typedef struct cJSON_Hooks {$/;"	s
cJSON_Hooks	Cpp/CJson.h	/^} cJSON_Hooks;$/;"	t	typeref:struct:cJSON_Hooks
cJSON_InitHooks	Cpp/CJson.c	/^void cJSON_InitHooks(cJSON_Hooks* hooks)$/;"	f
cJSON_InsertItemInArray	Cpp/CJson.c	/^void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}$/;"	f
cJSON_IsReference	Cpp/CJson.h	40;"	d
cJSON_Minify	Cpp/CJson.c	/^void cJSON_Minify(char *json)$/;"	f
cJSON_NULL	Cpp/CJson.h	34;"	d
cJSON_New_Item	Cpp/CJson.c	/^static cJSON *cJSON_New_Item(void)$/;"	f	file:
cJSON_Number	Cpp/CJson.h	35;"	d
cJSON_Object	Cpp/CJson.h	38;"	d
cJSON_Parse	Cpp/CJson.c	/^cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}$/;"	f
cJSON_ParseWithOpts	Cpp/CJson.c	/^cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)$/;"	f
cJSON_Print	Cpp/CJson.c	/^char *cJSON_Print(cJSON *item)				{return print_value(item,0,1,0);}$/;"	f
cJSON_PrintBuffered	Cpp/CJson.c	/^char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)$/;"	f
cJSON_PrintUnformatted	Cpp/CJson.c	/^char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0,0);}$/;"	f
cJSON_ReplaceItemInArray	Cpp/CJson.c	/^void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;$/;"	f
cJSON_ReplaceItemInObject	Cpp/CJson.c	/^void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}$/;"	f
cJSON_SetIntValue	Cpp/CJson.h	142;"	d
cJSON_SetNumberValue	Cpp/CJson.h	143;"	d
cJSON_String	Cpp/CJson.h	36;"	d
cJSON_StringIsConst	Cpp/CJson.h	41;"	d
cJSON_True	Cpp/CJson.h	33;"	d
cJSON__h	Cpp/CJson.h	24;"	d
cJSON_free	Cpp/CJson.c	/^void (*cJSON_free)(void *ptr) = free;$/;"	v
cJSON_malloc	Cpp/CJson.c	/^void *(*cJSON_malloc)(size_t sz) = malloc;$/;"	v
cJSON_strcasecmp	Cpp/CJson.c	/^static int cJSON_strcasecmp(const char *s1,const char *s2)$/;"	f	file:
cJSON_strdup	Cpp/CJson.c	/^char* cJSON_strdup(const char* str)$/;"	f
calcTotalLen	Cpp/HttpPacker.cpp	/^int HttpPacker::calcTotalLen()$/;"	f	class:HttpPacker
child	Cpp/CJson.h	/^	struct cJSON *child;		\/* An array or object item will have a child pointer pointing to a chain of the items in the array\/object. *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
create_reference	Cpp/CJson.c	/^static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}$/;"	f	file:
done_callback	Cpp/EmmManager-Test.cpp	/^void done_callback(int msgid)$/;"	f
emm_manager_test_main	Cpp/EmmManager-Test.cpp	/^int emm_manager_test_main(int argc, char **argv)$/;"	f
emm_str2_cmp	Cpp/HttpResponseParse.h	12;"	d
emm_str3_cmp	Cpp/HttpResponseParse.h	14;"	d
emm_str4_cmp	Cpp/HttpResponseParse.h	16;"	d
emmstr	Cpp/HttpPacker.h	/^typedef struct emmstr$/;"	s
emmstr	Cpp/HttpPacker.h	/^}emmstr;$/;"	t	typeref:struct:emmstr
ensure	Cpp/CJson.c	/^static char* ensure(printbuffer *p,int needed)$/;"	f	file:
ep	Cpp/CJson.c	/^static const char *ep;$/;"	v	file:
false	Cpp/threadpool.c	14;"	d	file:
firstByteMark	Cpp/CJson.c	/^static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };$/;"	v	file:
free_fn	Cpp/CJson.h	/^      void (*free_fn)(void *ptr);$/;"	m	struct:cJSON_Hooks
function	Cpp/threadpool.c	/^   void *(*function)(void *);$/;"	m	struct:__anon1	file:
init	Cpp/DataNode.cpp	/^	void DataNode::init()$/;"	f	class:DS::DataNode
is_thread_alive	Cpp/threadpool.c	/^is_thread_alive(pthread_t tid)$/;"	f
length	Cpp/CJson.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon2	file:
live_thr_num	Cpp/threadpool.c	/^   int live_thr_num;                     \/* 线程池中存活的线程数 *\/$/;"	m	struct:threadpool_t	file:
lock	Cpp/threadpool.c	/^   pthread_mutex_t lock;                 \/* 锁住整个结构体 *\/$/;"	m	struct:threadpool_t	file:
m_done_callback	Cpp/HttpRequest.h	/^	void (*m_done_callback)(int sockfd);$/;"	m	class:HttpRequest
m_eBody	Cpp/HttpPacker.h	/^	emmstr m_eBody;$/;"	m	class:HttpPacker
m_eHole	Cpp/HttpPacker.h	/^	emmstr m_eHole; $/;"	m	class:HttpPacker
m_hStatus	Cpp/HttpResponseParse.h	/^	enum HttpParsePhase m_hStatus;$/;"	m	class:HttpResponseParse	typeref:enum:HttpResponseParse::HttpParsePhase
m_mBodys	Cpp/HttpResponseParse.h	/^	std::map<int, DS::DataNode *> m_mBodys;$/;"	m	class:HttpResponseParse
m_mHeaders	Cpp/HttpPacker.h	/^	map<string, string> m_mHeaders;\/\/Content-Length:xxx$/;"	m	class:HttpPacker
m_mHeaders	Cpp/HttpResponseParse.h	/^	std::map<string, string>  m_mHeaders;$/;"	m	class:HttpResponseParse
m_nBodySerivalNo	Cpp/HttpResponseParse.h	/^	int m_nBodySerivalNo;$/;"	m	class:HttpResponseParse
m_nHandledEnd	Cpp/HttpResponseParse.h	/^	int m_nHandledEnd;\/\/ 已处理位置的标记，不能用 char * 记录，因为  m_pdDn 里面的数据可能做 marshal 操作 $/;"	m	class:HttpResponseParse
m_nHttpCode	Cpp/HttpResponseParse.h	/^	int m_nHttpCode;$/;"	m	class:HttpResponseParse
m_nMsgId	Cpp/HttpRequest.h	/^	int m_nMsgId;$/;"	m	class:HttpRequest
m_pdDn	Cpp/HttpResponseParse.h	/^	DS::DataNode *m_pdDn;		\/\/ d 表示类型简写$/;"	m	class:HttpResponseParse
m_sMethod	Cpp/HttpPacker.h	/^	string m_sMethod;$/;"	m	class:HttpPacker
m_sResponseLine	Cpp/HttpResponseParse.h	/^	std::string m_sResponseLine;\/\/ HTTP\/1.1 200 OK$/;"	m	class:HttpResponseParse
m_sUrl	Cpp/HttpPacker.h	/^	string m_sUrl;$/;"	m	class:HttpPacker
m_sVersion	Cpp/HttpPacker.h	/^	string m_sVersion;$/;"	m	class:HttpPacker
m_sockfd	Cpp/HttpRequest.h	/^	int m_sockfd;$/;"	m	class:HttpRequest
main	C/rm_dir.c	/^int main(int argc, char *argv[])$/;"	f
main	Cpp/BrainTest.cpp	/^int main(int argc, char **argv)$/;"	f
malloc_fn	Cpp/CJson.h	/^      void *(*malloc_fn)(size_t sz);$/;"	m	struct:cJSON_Hooks
max_thr_num	Cpp/threadpool.c	/^   int max_thr_num;                      \/* 线程池中最大线程数 *\/$/;"	m	struct:threadpool_t	file:
min_thr_num	Cpp/threadpool.c	/^   int min_thr_num;                      \/* 线程池中最小线程数 *\/$/;"	m	struct:threadpool_t	file:
mylog	C/rm_dir.c	/^int mylog(const char *format, ...)$/;"	f
next	Cpp/CJson.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
offset	Cpp/CJson.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon2	file:
packJsonData	Cpp/CJSONTest.cpp	/^cJSON* packJsonData()$/;"	f
parseBody	Cpp/HttpResponseParse.cpp	/^int HttpResponseParse::parseBody()$/;"	f	class:HttpResponseParse
parseBodyByContentLength	Cpp/HttpResponseParse.cpp	/^int HttpResponseParse::parseBodyByContentLength()$/;"	f	class:HttpResponseParse
parseBodyByTransferEncoding	Cpp/HttpResponseParse.cpp	/^int HttpResponseParse::parseBodyByTransferEncoding()$/;"	f	class:HttpResponseParse
parseBodyHtml	Cpp/HttpResponseParse.cpp	/^int HttpResponseParse::parseBodyHtml()$/;"	f	class:HttpResponseParse
parseHeaderItems	Cpp/HttpResponseParse.cpp	/^int HttpResponseParse::parseHeaderItems(const char *start, const char *end)$/;"	f	class:HttpResponseParse
parseHeaders	Cpp/HttpResponseParse.cpp	/^int HttpResponseParse::parseHeaders()$/;"	f	class:HttpResponseParse
parseJson	Cpp/CJSONTest.cpp	/^cJSON* parseJson(cJSON *root)$/;"	f
parseJson	Cpp/HttpResponseParse.cpp	/^int HttpResponseParse::parseJson()$/;"	f	class:HttpResponseParse
parseResponse	Cpp/HttpResponseParse.cpp	/^int HttpResponseParse::parseResponse()$/;"	f	class:HttpResponseParse
parse_array	Cpp/CJson.c	/^static const char *parse_array(cJSON *item,const char *value)$/;"	f	file:
parse_hex4	Cpp/CJson.c	/^static unsigned parse_hex4(const char *str)$/;"	f	file:
parse_number	Cpp/CJson.c	/^static const char *parse_number(cJSON *item,const char *num)$/;"	f	file:
parse_object	Cpp/CJson.c	/^static const char *parse_object(cJSON *item,const char *value)$/;"	f	file:
parse_string	Cpp/CJson.c	/^static const char *parse_string(cJSON *item,const char *str)$/;"	f	file:
parse_value	Cpp/CJson.c	/^static const char *parse_value(cJSON *item,const char *value)$/;"	f	file:
pow2gt	Cpp/CJson.c	/^static int pow2gt (int x)	{	--x;	x|=x>>1;	x|=x>>2;	x|=x>>4;	x|=x>>8;	x|=x>>16;	return x+1;	}$/;"	f	file:
prev	Cpp/CJson.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::
print_array	Cpp/CJson.c	/^static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:
print_number	Cpp/CJson.c	/^static char *print_number(cJSON *item,printbuffer *p)$/;"	f	file:
print_object	Cpp/CJson.c	/^static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:
print_string	Cpp/CJson.c	/^static char *print_string(cJSON *item,printbuffer *p)	{return print_string_ptr(item->valuestring,p);}$/;"	f	file:
print_string_ptr	Cpp/CJson.c	/^static char *print_string_ptr(const char *str,printbuffer *p)$/;"	f	file:
print_value	Cpp/CJson.c	/^static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:
printbuffer	Cpp/CJson.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	t	typeref:struct:__anon2	file:
queue_front	Cpp/threadpool.c	/^   int queue_front;                      \/* 队头 *\/$/;"	m	struct:threadpool_t	file:
queue_max_size	Cpp/threadpool.c	/^   int queue_max_size;                   \/* 队列能容纳的最大任务数 *\/$/;"	m	struct:threadpool_t	file:
queue_not_empty	Cpp/threadpool.c	/^   pthread_cond_t  queue_not_empty;      \/* 任务队列不为空 *\/$/;"	m	struct:threadpool_t	file:
queue_not_full	Cpp/threadpool.c	/^   pthread_cond_t  queue_not_full;       \/* 条件变量，任务队列不为满 *\/$/;"	m	struct:threadpool_t	file:
queue_rear	Cpp/threadpool.c	/^   int queue_rear;                       \/* 队尾 *\/$/;"	m	struct:threadpool_t	file:
queue_size	Cpp/threadpool.c	/^   int queue_size; $/;"	m	struct:threadpool_t	file:
remove_dir_sub	C/rm_dir.c	/^int remove_dir_sub(char *dir_full_path)$/;"	f
remove_dir_sub_and_self	C/rm_dir.c	/^int remove_dir_sub_and_self(char *dir_full_path)$/;"	f
show	Cpp/cfg_reader.cpp	/^void CCfgReader::show() {$/;"	f	class:ACE::CCfgReader
showJson	Cpp/CJSONTest.cpp	/^void showJson(cJSON *root)$/;"	f
shutdown	Cpp/threadpool.c	/^   int shutdown;                         \/* true为关闭 *\/$/;"	m	struct:threadpool_t	file:
size	Cpp/HttpPacker.h	/^	int size;$/;"	m	struct:emmstr
skip	Cpp/CJson.c	/^static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}$/;"	f	file:
string	Cpp/CJson.h	/^	char *string;				\/* The item's name string, if this item is the child of, or is in the list of subitems of an object. *\/$/;"	m	struct:cJSON
suffix_object	Cpp/CJson.c	/^static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}$/;"	f	file:
task_queue	Cpp/threadpool.c	/^   threadpool_task_t *task_queue;        \/* 任务队列 *\/$/;"	m	struct:threadpool_t	file:
test_del_self	C/rm_dir.c	/^void test_del_self()$/;"	f
test_remove_sub	C/rm_dir.c	/^void test_remove_sub()$/;"	f
thread_counter	Cpp/threadpool.c	/^   pthread_mutex_t thread_counter;       \/* 用于使用忙线程数时的锁 *\/$/;"	m	struct:threadpool_t	file:
threadpool_add_task	Cpp/threadpool.c	/^threadpool_add_task(threadpool_t *pool, void *(*function)(void *arg), void *arg)$/;"	f
threadpool_create	Cpp/threadpool.c	/^threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size)$/;"	f
threadpool_destroy	Cpp/threadpool.c	/^threadpool_destroy(threadpool_t *pool)$/;"	f
threadpool_free	Cpp/threadpool.c	/^threadpool_free(threadpool_t *pool)$/;"	f
threadpool_t	Cpp/threadpool.c	/^struct threadpool_t{$/;"	s	file:
threadpool_t	Cpp/threadpool.h	/^typedef struct threadpool_t threadpool_t;$/;"	t	typeref:struct:threadpool_t
threadpool_task_t	Cpp/threadpool.c	/^} threadpool_task_t;$/;"	t	typeref:struct:__anon1	file:
threadpool_thread	Cpp/threadpool.c	/^threadpool_thread(void *threadpool)$/;"	f
threadpooltest	xBrainTest-Dev-C++/threadpool-test.h	/^void threadpooltest()$/;"	f
threads	Cpp/threadpool.c	/^   pthread_t *threads;                   \/* 存放线程的tid,实际上就是管理了线 数组 *\/$/;"	m	struct:threadpool_t	file:
tmp	build/Makefile	/^tmp = $(notdir $(OBJS))$/;"	m
tmp_cpp	build/Makefile	/^tmp_cpp = $(notdir $(OBJS_CPP))$/;"	m
toUpper	Cpp/HttpPacker.cpp	/^void HttpPacker::toUpper(std::string &str)$/;"	f	class:HttpPacker
true	Cpp/threadpool.c	13;"	d	file:
type	Cpp/CJson.h	/^	int type;					\/* The type of the item, as above. *\/$/;"	m	struct:cJSON
update	Cpp/CJson.c	/^static int update(printbuffer *p)$/;"	f	file:
valuedouble	Cpp/CJson.h	/^	double valuedouble;			\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON
valueint	Cpp/CJson.h	/^	int valueint;				\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON
valuestring	Cpp/CJson.h	/^	char *valuestring;			\/* The item's string, if type==cJSON_String *\/$/;"	m	struct:cJSON
wait_exit_thr_num	Cpp/threadpool.c	/^   int wait_exit_thr_num;                \/* 需要销毁的线程数 *\/$/;"	m	struct:threadpool_t	file:
~CCfgReader	Cpp/cfg_reader.cpp	/^CCfgReader::~CCfgReader() {$/;"	f	class:ACE::CCfgReader
~DataNode	Cpp/DataNode.cpp	/^	DataNode::~DataNode()$/;"	f	class:DS::DataNode
~HttpPacker	Cpp/HttpPacker.cpp	/^HttpPacker::~HttpPacker()$/;"	f	class:HttpPacker
~HttpRequest	Cpp/HttpRequest.cpp	/^HttpRequest::~HttpRequest()$/;"	f	class:HttpRequest
~HttpResponseParse	Cpp/HttpResponseParse.cpp	/^HttpResponseParse::~HttpResponseParse()$/;"	f	class:HttpResponseParse
